{"version":3,"sources":["meteor://ðŸ’»app/packages/cfs:tempstore/tempStore.js"],"names":["EventEmitter","Npm","require","CombinedStream","FS","TempStore","tracker","Tracker","Mongo","Collection","Storage","mountStorage","Package","Store","GridFS","internal","FileSystem","Error","debug","console","log","typeName","mountFile","fileObj","name","isMounted","on","chunkNum","count","total","result","_chunkPath","n","_fileReference","chunk","existing","findOne","fileId","_id","collectionName","tempFileObj","File","original","copies","_tempstore","key","keys","adapter","fileKey","exists","listParts","fsTempStoreListParts","self","warn","removeFile","fsTempStoreRemoveFile","emit","chunkInfo","Utility","each","remove","noop","removeAll","fsTempStoreRemoveAll","find","forEach","createWriteStream","options","selector","chunkSum","upsert","$setOnInsert","isOnePart","isMultiPart","isStoreSync","writeStream","safeOn","setObj","update","$set","temp","chunkCount","size","modifier","instance_id","process","env","COLLECTIONFS_ENV_NAME_UNIQUE_ID","METEOR_PARENT_PID","$unset","chunkSize","uploadedAt","Date","synchronizedAt","eventName","error","createReadStream","totalChunks","getNextStreamFunc","Meteor","bindEnvironment","next","chunkReadStream","combinedStream","create","currentChunk","append"],"mappings":"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","file":"/packages/cfs_tempstore.js","sourcesContent":["// ##Temporary Storage\n//\n// Temporary storage is used for chunked uploads until all chunks are received\n// and all copies have been made or given up. In some cases, the original file\n// is stored only in temporary storage (for example, if all copies do some\n// manipulation in beforeSave). This is why we use the temporary file as the\n// basis for each saved copy, and then remove it after all copies are saved.\n//\n// Every chunk is saved as an individual temporary file. This is safer than\n// attempting to write multiple incoming chunks to different positions in a\n// single temporary file, which can lead to write conflicts.\n//\n// Using temp files also allows us to easily resume uploads, even if the server\n// restarts, and to keep the working memory clear.\n\n// The FS.TempStore emits events that others are able to listen to\nvar EventEmitter = Npm.require('events').EventEmitter;\n\n// We have a special stream concating all chunk files into one readable stream\nvar CombinedStream = Npm.require('combined-stream');\n\n/** @namespace FS.TempStore\n * @property FS.TempStore\n * @type {object}\n * @public\n * @summary An event emitter\n */\nFS.TempStore = new EventEmitter();\n\n// Create a tracker collection for keeping track of all chunks for any files that are currently in the temp store\nvar tracker = FS.TempStore.Tracker = new Mongo.Collection('cfs._tempstore.chunks');\n\n/**\n * @property FS.TempStore.Storage\n * @type {StorageAdapter}\n * @namespace FS.TempStore\n * @private\n * @summary This property is set to either `FS.Store.FileSystem` or `FS.Store.GridFS`\n *\n * __When and why:__\n * We normally default to `cfs-filesystem` unless its not installed. *(we default to gridfs if installed)*\n * But if `cfs-gridfs` and `cfs-worker` is installed we default to `cfs-gridfs`\n *\n * If `cfs-gridfs` and `cfs-filesystem` is not installed we log a warning.\n * the user can set `FS.TempStore.Storage` them selfs eg.:\n * ```js\n *   // Its important to set `internal: true` this lets the SA know that we\n *   // are using this internally and it will give us direct SA api\n *   FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });\n * ```\n *\n * > Note: This is considered as `advanced` use, its not a common pattern.\n */\nFS.TempStore.Storage = null;\n\n// We will not mount a storage adapter until needed. This allows us to check for the\n// existance of FS.FileWorker, which is loaded after this package because it\n// depends on this package.\nfunction mountStorage() {\n\n  if (FS.TempStore.Storage) return;\n\n  // XXX: We could replace this test, testing the FS scope for grifFS etc.\n  // This is on the todo later when we get \"stable\"\n  if (Package[\"cfs:gridfs\"] && (Package[\"cfs:worker\"] || !Package[\"cfs:filesystem\"])) {\n    // If the file worker is installed we would prefer to use the gridfs sa\n    // for scalability. We also default to gridfs if filesystem is not found\n\n    // Use the gridfs\n    FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });\n  } else if (Package[\"cfs:filesystem\"]) {\n\n    // use the Filesystem\n    FS.TempStore.Storage = new FS.Store.FileSystem('_tempstore', { internal: true });\n  } else {\n    throw new Error('FS.TempStore.Storage is not set: Install cfs:filesystem or cfs:gridfs or set it manually');\n  }\n\n  FS.debug && console.log('TempStore is mounted on', FS.TempStore.Storage.typeName);\n}\n\nfunction mountFile(fileObj, name) {\n  if (!fileObj.isMounted()) {\n    throw new Error(name + ' cannot work with unmounted file');\n  }\n}\n\n// We update the fileObj on progress\nFS.TempStore.on('progress', function(fileObj, chunkNum, count, total, result) {\n  FS.debug && console.log('TempStore progress: Received ' + count + ' of ' + total + ' chunks for ' + fileObj.name());\n});\n\n// XXX: TODO\n// FS.TempStore.on('stored', function(fileObj, chunkCount, result) {\n//   // This should work if we pass on result from the SA on stored event...\n//   fileObj.update({ $set: { chunkSum: 1, chunkCount: chunkCount, size: result.size } });\n// });\n\n// Stream implementation\n\n/**\n * @method _chunkPath\n * @private\n * @param {Number} [n] Chunk number\n * @returns {String} Chunk naming convention\n */\n_chunkPath = function(n) {\n  return (n || 0) + '.chunk';\n};\n\n/**\n * @method _fileReference\n * @param {FS.File} fileObj\n * @param {Number} chunk\n * @private\n * @returns {String} Generated SA specific fileKey for the chunk\n *\n * Note: Calling function should call mountStorage() first, and\n * make sure that fileObj is mounted.\n */\n_fileReference = function(fileObj, chunk, existing) {\n  // Maybe it's a chunk we've already saved\n  existing = existing || tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});\n\n  // Make a temporary fileObj just for fileKey generation\n  var tempFileObj = new FS.File({\n    collectionName: fileObj.collectionName,\n    _id: fileObj._id,\n    original: {\n      name: _chunkPath(chunk)\n    },\n    copies: {\n      _tempstore: {\n        key: existing && existing.keys[chunk]\n      }\n    }\n  });\n\n  // Return a fitting fileKey SA specific\n  return FS.TempStore.Storage.adapter.fileKey(tempFileObj);\n};\n\n/**\n * @method FS.TempStore.exists\n * @param {FS.File} File object\n * @returns {Boolean} Is this file, or parts of it, currently stored in the TempStore\n */\nFS.TempStore.exists = function(fileObj) {\n  var existing = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});\n  return !!existing;\n};\n\n/**\n * @method FS.TempStore.listParts\n * @param {FS.File} fileObj\n * @returns {Object} of parts already stored\n * @todo This is not yet implemented, milestone 1.1.0\n */\nFS.TempStore.listParts = function fsTempStoreListParts(fileObj) {\n  var self = this;\n  console.warn('This function is not correctly implemented using SA in TempStore');\n  //XXX This function might be necessary for resume. Not currently supported.\n};\n\n/**\n * @method FS.TempStore.removeFile\n * @public\n * @param {FS.File} fileObj\n * This function removes the file from tempstorage - it cares not if file is\n * already removed or not found, goal is reached anyway.\n */\nFS.TempStore.removeFile = function fsTempStoreRemoveFile(fileObj) {\n  var self = this;\n\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  // If fileObj is not mounted or can't be, throw an error\n  mountFile(fileObj, 'FS.TempStore.removeFile');\n\n  // Emit event\n  self.emit('remove', fileObj);\n\n  var chunkInfo = tracker.findOne({\n    fileId: fileObj._id,\n    collectionName: fileObj.collectionName\n  });\n\n  if (chunkInfo) {\n\n    // Unlink each file\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {\n      var fileKey = _fileReference(fileObj, chunk, chunkInfo);\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);\n    });\n\n    // Remove fileObj from tracker collection, too\n    tracker.remove({_id: chunkInfo._id});\n\n  }\n};\n\n/**\n * @method FS.TempStore.removeAll\n * @public\n * @summary This function removes all files from tempstorage - it cares not if file is\n * already removed or not found, goal is reached anyway.\n */\nFS.TempStore.removeAll = function fsTempStoreRemoveAll() {\n  var self = this;\n\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  tracker.find().forEach(function (chunkInfo) {\n    // Unlink each file\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {\n      var fileKey = _fileReference({_id: chunkInfo.fileId, collectionName: chunkInfo.collectionName}, chunk, chunkInfo);\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);\n    });\n\n    // Remove from tracker collection, too\n    tracker.remove({_id: chunkInfo._id});\n  });\n};\n\n/**\n * @method FS.TempStore.createWriteStream\n * @public\n * @param {FS.File} fileObj File to store in temporary storage\n * @param {Number | String} [options]\n * @returns {Stream} Writeable stream\n *\n * `options` of different types mean differnt things:\n * * `undefined` We store the file in one part\n * *(Normal server-side api usage)*\n * * `Number` the number is the part number total\n * *(multipart uploads will use this api)*\n * * `String` the string is the name of the `store` that wants to store file data\n * *(stores that want to sync their data to the rest of the files stores will use this)*\n *\n * > Note: fileObj must be mounted on a `FS.Collection`, it makes no sense to store otherwise\n */\nFS.TempStore.createWriteStream = function(fileObj, options) {\n  var self = this;\n\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  // If fileObj is not mounted or can't be, throw an error\n  mountFile(fileObj, 'FS.TempStore.createWriteStream');\n\n  // Cache the selector for use multiple times below\n  var selector = {fileId: fileObj._id, collectionName: fileObj.collectionName};\n\n  // TODO, should pass in chunkSum so we don't need to use FS.File for it\n  var chunkSum = fileObj.chunkSum || 1;\n\n  // Add fileObj to tracker collection\n  tracker.upsert(selector, {$setOnInsert: {keys: {}}});\n\n  // Determine how we're using the writeStream\n  var isOnePart = false, isMultiPart = false, isStoreSync = false, chunkNum = 0;\n  if (options === +options) {\n    isMultiPart = true;\n    chunkNum = options;\n  } else if (options === ''+options) {\n    isStoreSync = true;\n  } else {\n    isOnePart = true;\n  }\n\n  // XXX: it should be possible for a store to sync by storing data into the\n  // tempstore - this could be done nicely by setting the store name as string\n  // in the chunk variable?\n  // This store name could be passed on the the fileworker via the uploaded\n  // event\n  // So the uploaded event can return:\n  // undefined - if data is stored into and should sync out to all storage adapters\n  // number - if a chunk has been uploaded\n  // string - if a storage adapter wants to sync its data to the other SA's\n\n  // Find a nice location for the chunk data\n  var fileKey = _fileReference(fileObj, chunkNum);\n\n  // Create the stream as Meteor safe stream\n  var writeStream = FS.TempStore.Storage.adapter.createWriteStream(fileKey);\n\n  // When the stream closes we update the chunkCount\n  writeStream.safeOn('stored', function(result) {\n    // Save key in tracker document\n    var setObj = {};\n    setObj['keys.' + chunkNum] = result.fileKey;\n    tracker.update(selector, {$set: setObj});\n\n    var temp = tracker.findOne(selector);\n\n    if (!temp) {\n      FS.debug && console.log('NOT FOUND FROM TEMPSTORE => EXIT (REMOVED)');\n      return;\n    }\n\n    // Get updated chunkCount\n    var chunkCount = FS.Utility.size(temp.keys);\n\n    // Progress\n    self.emit('progress', fileObj, chunkNum, chunkCount, chunkSum, result);\n\n    var modifier = { $set: {} };\n    if (!fileObj.instance_id) {\n      modifier.$set.instance_id = process.env.COLLECTIONFS_ENV_NAME_UNIQUE_ID ? process.env[process.env.COLLECTIONFS_ENV_NAME_UNIQUE_ID] : process.env.METEOR_PARENT_PID;\n    }\n\n    // If upload is completed\n    if (chunkCount === chunkSum) {\n      // We no longer need the chunk info\n      modifier.$unset = {chunkCount: 1, chunkSum: 1, chunkSize: 1};\n\n      // Check if the file has been uploaded before\n      if (typeof fileObj.uploadedAt === 'undefined') {\n        // We set the uploadedAt date\n        modifier.$set.uploadedAt = new Date();\n      } else {\n        // We have been uploaded so an event were file data is updated is\n        // called synchronizing - so this must be a synchronizedAt?\n        modifier.$set.synchronizedAt = new Date();\n      }\n\n      // Update the fileObject\n      fileObj.update(modifier);\n\n      // Fire ending events\n      var eventName = isStoreSync ? 'synchronized' : 'stored';\n      self.emit(eventName, fileObj, result);\n\n      // XXX is emitting \"ready\" necessary?\n      self.emit('ready', fileObj, chunkCount, result);\n    } else {\n      // Update the chunkCount on the fileObject\n      modifier.$set.chunkCount = chunkCount;\n      fileObj.update(modifier);\n    }\n  });\n\n  // Emit errors\n  writeStream.on('error', function (error) {\n    FS.debug && console.log('TempStore writeStream error:', error);\n    self.emit('error', error, fileObj);\n  });\n\n  return writeStream;\n};\n\n/**\n  * @method FS.TempStore.createReadStream\n  * @public\n  * @param {FS.File} fileObj The file to read\n  * @return {Stream} Returns readable stream\n  *\n  */\nFS.TempStore.createReadStream = function(fileObj) {\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\n  mountStorage();\n\n  // If fileObj is not mounted or can't be, throw an error\n  mountFile(fileObj, 'FS.TempStore.createReadStream');\n\n  FS.debug && console.log('FS.TempStore creating read stream for ' + fileObj._id);\n\n  // Determine how many total chunks there are from the tracker collection\n  var chunkInfo = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName}) || {};\n  var totalChunks = FS.Utility.size(chunkInfo.keys);\n\n  function getNextStreamFunc(chunk) {\n    return Meteor.bindEnvironment(function(next) {\n      var fileKey = _fileReference(fileObj, chunk);\n      var chunkReadStream = FS.TempStore.Storage.adapter.createReadStream(fileKey);\n      next(chunkReadStream);\n    }, function (error) {\n      throw error;\n    });\n  }\n\n  // Make a combined stream\n  var combinedStream = CombinedStream.create();\n\n  // Add each chunk stream to the combined stream when the previous chunk stream ends\n  var currentChunk = 0;\n  for (var chunk = 0; chunk < totalChunks; chunk++) {\n    combinedStream.append(getNextStreamFunc(chunk));\n  }\n\n  // Return the combined stream\n  return combinedStream;\n};\n"]}